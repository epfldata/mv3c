Mapping of operations from M3Map into Store by example

- val m = M3Map.make[(Long,Long),Double]((k:(Long,Long))=>k._1) // projections functions
  ==>
  val m = Store[Entry_<UNIQ>]( <#proj> ) // needs to be per-table or (type+projections) combined
  case class Entry_<UNIQ>(var _1:Long=0, var _2:Long=0, var _3:Double=0) extends storage.Entry(<size(key)+1>) {
    def hash(i: Int):Int = // the code/indexes should remains the same
    def cmp(i: Int, e0:Entry):Int = // ditto
    def copy = Entry_<UNIQ>(_1, _2, _3)
  }

Operations (Entry_<UNIQ> = En, m=M3Map, s=Store):
- def get(key:K):V;           // returns the value or zero if it is not present
  m.get((a,b)) ==> { val e=En(a,b,<0>) val r=s.get(e); if (r==null) e else r }

- def set(key:K, value:V)
  m.set((a,b),c) ==> if (c!=0) { val e=En(a,b,c); val r=s.get(e); if (r==null) s.insert(e) else r._3=c }

- def add(key:K, value:V)
  m.add((a,b),c) ==> { val e=En(a,b,c); val r=s.get(e); if (r==null) s.insert(e) else r._3+=c; """ if (r._3==0) s.delete(r) """ } // """ when 0 is pruned
  + M3Map.temp[K,V]():M3Map[K,V] ==> 0 is not pruned
  + M3Map.make[K,V](projs:K=>_ *):M3Map[K,V] ==> 0 is pruned

- def foreach(f:(K,V)=>Unit)
  m.foreach((k,v) ==> f(k._1,k._2,v)) => s.foreach{ e => f(e._1,e._2,e._3); }

- def slice(index:Int,subKey:T)
  m.slice(i,(a,b)).foreach{ (k,v) ==> f(k,v) } => s.slice(i+1,En(a,b,0),{ e => f(e._1,e._2,e._3); })

- def sum(acc:M3Map[K,V])
  m.sum(m2) ==> s.foreach { e=> val r=s2.get(e); if (r==null) s.insert(e) else r._3+=e._3 }

- def toMap:Map[K,V]
  m.toMap ==> { val m=new HashMap[K,V]; s.foreach{ e => m.put((e._1,e._2),e._3); } m }
